{"version":3,"file":"tokens.js","sourceRoot":"","sources":["../../../../src/contracts/tokens.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport { BigNumberish, Contract, getBigInt, isAddress, Signer, TransactionResponse } from 'ethers';\nimport { GeniDex } from './genidex';\nimport { ERC20 } from './erc20';\nimport { OutputOrder, TokenInfo } from '../types';\n\nexport class Tokens {\n    genidex!: GeniDex;\n    contract: Contract;\n    public tokensInfo: Record<string, TokenInfo> = {};\n\n    constructor(_genidex: GeniDex) {\n        this.genidex = _genidex;\n        this.contract = _genidex.contract;\n    }\n\n    /**\n     * Fetch metadata for a list of token addresses from the GeniDex contract.\n     *\n     * This method calls the on-chain `getTokensInfo(address[])` view function,\n     * which returns details such as symbol, decimals, and market association for each token.\n     *\n     * @param tokenAddresses - An array of token contract addresses to query.\n     * @returns A Promise resolving to an array of TokenInfo objects containing metadata for each token.\n     *\n     * Example output:\n     * [\n     *   {\n     *     tokenAddress: \"0xabc...\",\n     *     symbol: \"USDC\",\n     *     usdMarketID: 1n,\n     *     minOrderAmount: 10000000000000000000n\n     *     decimals: 6,\n     *     isUSD: true\n     *   },\n     *   ...\n     * ]\n     */\n    async getTokensInfo(tokenAddresses: string[]): Promise<TokenInfo[]> {\n        const rawResults = await this.contract.getTokensInfo(tokenAddresses);\n        return rawResults.map((item: any) => ({\n            tokenAddress: item.tokenAddress,\n            symbol: item.symbol,\n            usdMarketID: BigInt(item.usdMarketID.toString()),\n            minOrderAmount: BigInt(item.minOrderAmount.toString()),\n            decimals: Number(item.decimals),\n            isUSD: item.isUSD,\n        }));\n    }\n\n    /**\n     * Get metadata of a specific token.\n     * If already cached, return from this.tokens.\n     * Otherwise, fetch from contract and cache it.\n     *\n     * @param tokenAddress The address of the token.\n     * @returns Promise resolving to TokenInfo or undefined if fetch fails.\n     */\n    async getTokenInfo(tokenAddress: string): Promise<TokenInfo | any> {\n        const key = tokenAddress.toLowerCase();\n        // Return from cache if available\n        if (this.tokensInfo[key]) {\n            return this.tokensInfo[key];\n        }\n        // validate input\n        if (!isAddress(tokenAddress)) {\n            throw new Error(`Invalid token address: ${tokenAddress}`);\n        }\n        try {\n            const infos = await this.getTokensInfo([tokenAddress]);\n            if (infos.length === 1) {\n                this.tokensInfo[key] = infos[0];\n                return infos[0];\n            }\n        } catch (err) {\n            console.error(\"Failed to fetch token info:\", err);\n        }\n\n        return {};\n    }\n\n    /**\n     * Fetch all unique token addresses that are listed in any market.\n     * This includes both base and quote tokens.\n     * @returns A Promise resolving to an array of unique token addresses.\n     */\n    async getAllTokens(): Promise<string[]> {\n        const rawMarkets = await this.contract.getAllMarkets();\n        const tokenSet = new Set<string>();\n        for (const m of rawMarkets) {\n            tokenSet.add(m.baseAddress.toLowerCase());\n            tokenSet.add(m.quoteAddress.toLowerCase());\n        }\n        return Array.from(tokenSet);\n    }\n\n    /**\n     * Fetch metadata for all unique tokens listed in any market.\n     * Returns a record where keys are token addresses (lowercased)\n     * and values are TokenInfo objects.\n     *\n     * Example:\n     * {\n     *   \"0xabc...\": { tokenAddress: \"0xabc...\", symbol: \"USDC\", ... },\n     *   \"0xdef...\": { tokenAddress: \"0xdef...\", symbol: \"WETH\", ... },\n     * }\n     *\n     * @returns Promise resolving to a record of tokenAddress -> TokenInfo.\n     */\n    async getAllTokensInfo(): Promise<Record<string, TokenInfo>> {\n        const tokenAddresses = await this.getAllTokens();\n        const tokensInfo = await this.getTokensInfo(tokenAddresses);\n        const result: Record<string, TokenInfo> = {};\n        for (const info of tokensInfo) {\n            result[info.tokenAddress.toLowerCase()] = info;\n        }\n        this.tokensInfo = result; // cache the result\n        return result;\n    }\n\n\n}\n"]}