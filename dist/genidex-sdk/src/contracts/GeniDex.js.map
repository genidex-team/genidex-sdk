{"version":3,"file":"genidex.js","sourceRoot":"","sources":["../../../../src/contracts/genidex.ts"],"names":[],"mappings":"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","sourcesContent":["import { BigNumberish, Contract,\n    ContractTransactionResponse,\n    ErrorDescription, getBigInt, Interface, JsonRpcProvider, Network,\n    Provider, Signer, TransactionReceipt, TransactionResponse, \n    WebSocketProvider, parseUnits,\n    ContractTransactionReceipt, TransactionRequest,\n    Result} from 'ethers';\nimport { abi } from '../../../genidex_contract/artifacts/contracts/GeniDex.sol/GeniDex.json';\nimport { Markets } from './markets';\nimport { Balances } from './balances';\nimport { BuyOrders } from './buy.orders';\nimport { TokenInfo, Market, OutputOrder, NetworkConfig, NetworkName, GeniDexTransactionResponse, WaitOpts } from \"../types\";\nimport { SellOrders } from './sell.orders';\nimport { Tokens } from './tokens';\nimport { IERC20Errors } from './abis/ierc20.errors';\nimport {config} from '../config/config';\nimport { Tx } from './tx';\nimport { utils } from \"../utils\";\n\ntype writeContractParams = {\n    signer: Signer;\n    method: string;\n    args?: any[];\n    overrides?: TransactionRequest\n}\n\n/**\n * @group GeniDex\n */\nexport class GeniDex {\n    public abi: any;\n    public iface!: Interface;\n    public network!: NetworkConfig;\n    public contract!: Contract;\n    public provider!: WebSocketProvider | JsonRpcProvider;\n    public address!: string;\n    public markets!: Markets;\n    public tokens!: Tokens;\n    public balances!: Balances;\n    public buyOrders!: BuyOrders;\n    public sellOrders!: SellOrders;\n    public tx!: Tx;\n    private verifiedProvider = false;\n    private verifiedContract = false;\n\n    constructor() {\n    }\n\n    async connect(\n        networkName: NetworkName | string,\n        provider: WebSocketProvider | JsonRpcProvider\n    ){\n        await this.verifyProviderNetwork(networkName, provider);\n        this.abi        = abi;\n        this.iface      = new Interface(this.abi);\n        this.provider   = provider;\n        this.network    = config.getNetwork(networkName);\n        this.address    = this.network.contracts.GeniDex;\n        this.contract   = new Contract(this.address, abi, provider);\n        this.markets    = new Markets(this);\n        this.tokens     = new Tokens(this);\n        this.balances   = new Balances(this);\n        this.buyOrders  = new BuyOrders(this);\n        this.sellOrders = new SellOrders(this);\n        this.tx         = new Tx(this);\n    }\n\n    /**\n     * Verifies that the provider is connected to the expected chain ID from this.network\n     * @throws if the chain ID does not match\n     */\n    async verifyProviderNetwork(networkName: NetworkName | string, provider: any): Promise<boolean> {\n        if(this.verifiedProvider) return true;\n        const network = config.getNetwork(networkName)\n\n        const currentNetwork = await provider.getNetwork();\n        const currentChainId = currentNetwork.chainId;\n        if (currentChainId !== network.chainId) {\n            throw new Error(\n                `Chain ID mismatch: expected ${network.chainId}, got ${currentChainId}`\n            );\n        }\n        this.verifiedProvider = true;\n        return true;\n        // console.log('verified ProviderNetwork')\n    }\n\n    /**\n     * Returns a new contract instance using the provided signer.\n     * If no signer is passed, it falls back to the provider (read-only).\n     *\n     * @param signer - Optional signer for sending transactions.\n     * @returns A new Contract instance connected with signer or provider.\n     */\n    getContract(signer?: Signer): Contract {\n        const runner = signer ?? this.provider;\n        return new Contract(this.address, this.abi, runner);\n    }\n\n    /**\n     * Calculate fee based on normalized amount.\n     *\n     * Formula: fee = normAmount / 1000n (0.1%)\n     *\n     * @param normAmount - The normalized amount (18 decimals), as bigint or string.\n     * @returns Fee amount (also in 18 decimals), as bigint.\n     */\n    calculateFee(normAmount: bigint | string): bigint {\n        const amount = typeof normAmount === \"string\" ? BigInt(normAmount) : normAmount;\n        return amount / 1000n;\n    }\n\n    /**\n     * Returns IDs of buy orders that have been fully filled (quantity == 0).\n     *\n     * @param orders - Array of orders (OutputOrder[])\n     * @returns Array of filled order IDs (bigint[])\n     */\n    getFilledOrderIDs(orders: OutputOrder[]): bigint[] {\n        return orders\n            .filter(order => getBigInt(order.quantity) === 0n)\n            .map(order => order.id);\n    }\n\n    /**\n     * Selects sell order IDs (sorted ascending by price) such that\n     * the cumulative quantity exceeds or equals the requested normQuantity.\n     *\n     * @param sortedOrders - Array of orders sorted by price ascending\n     * @param normQuantity - Maximum total quantity needed\n     * @returns Array of order IDs\n     */\n    getMatchingOrderIds(sortedOrders: OutputOrder[], normQuantity: BigNumberish): BigNumberish[] {\n        const selectedIds: BigNumberish[] = [];\n        let total = 0n;\n        const target = getBigInt(normQuantity);\n\n        for (const order of sortedOrders) {\n            if (total >= target) break;\n\n            selectedIds.push(order.id);\n            total += order.quantity;\n        }\n\n        return selectedIds;\n    }\n\n    async writeContract({\n        signer,\n        method,\n        args = [],\n        overrides = {}\n    }: writeContractParams ): Promise<GeniDexTransactionResponse | undefined> {\n        const contract = new Contract(this.address, this.abi, signer);\n        this.verifyMethodExists(contract, method);\n        await Promise.all([\n            this.verifyContractExists(),\n            this.verifySignerNetwork(signer),\n            this.verifyStaticCallSucceeds(contract, method, args, overrides)\n        ]);\n        try {\n            // const tx = await contract[method](...args, overrides);\n            const tx = await contract.getFunction(method).send(...args, overrides);\n            (tx as GeniDexTransactionResponse).waitForConfirms = async (): Promise<TransactionReceipt | undefined>=>{\n                return await this.waitForConfirms(tx, method, args, overrides, {});\n                // return await this.waitForConfirms1(tx, 1, method, args);\n            };\n            return (tx as GeniDexTransactionResponse);\n        } catch (error) {\n            await this.revertError(error, method, args, overrides);\n        }\n    }\n\n    async readContract(\n        method: string,\n        args: any[] = []\n    ): Promise<any> {\n        try {\n            this.verifyMethodExists(this.contract, method);\n            const result = await this.contract[method](...args);\n            return result;\n        } catch (err) {\n            await this.verifyContractExists();\n            // console.error(`readContract: Error calling \"${method}\"`, err);\n            throw err;\n        }\n    }\n\n    /**\n     * Verifies that the given signer is connected to the same network as this.network.chainId\n     * @param signer - The signer to verify\n     * @throws if chainId mismatch\n     */\n    async verifySignerNetwork(signer: Signer): Promise<void> {\n        if (!signer.provider) return;\n\n        const signerChainId = (await signer.provider.getNetwork()).chainId;\n        if (signerChainId !== this.network.chainId) {\n            throw new Error(\n                `Chain ID mismatch: expected ${this.network.chainId}, got ${signerChainId}`\n            );\n        }\n        // console.log('verified SignerNetwork')\n    }\n\n    async waitForConfirms1(\n        tx: TransactionResponse,\n        confirmations: number,\n        method: string,\n        args: any[] = []\n    ): Promise<TransactionReceipt | undefined> {\n        try {\n            const receipt = await tx.wait(confirmations);\n            // const receipt = await this.provider.waitForTransaction(tx.hash);\n            if (receipt?.status === 1) {\n                return receipt;\n            } else {\n                throw new Error(`Transaction reverted on-chain: ${tx.hash}`);\n            }\n        } catch (error: any) {\n            try{\n                await this.provider.call({\n                    ...tx,\n                    blockTag: error.receipt.blockNumber\n                });\n                // console.log('rawData', rawData);\n            }catch(error2: any){\n                // console.log('error2')\n                error2.receipt = error.receipt;\n                await this.revertError(error2, method, args);\n            }\n            await this.revertError(error, method, args);\n        }\n    }\n\n    /**\n     * Wait for a transaction hash with richer control than tx.wait().\n     * Throws if the tx is dropped/replaced, if it reverts, or if the timeout elapses.\n    */\n    async waitForConfirms(\n        tx: ContractTransactionResponse,\n        functionName: string,\n        args?: any[],\n        overrides?: {},\n        opts: WaitOpts = {},\n    ) {\n        let {\n            confirmations = 1,\n            timeoutMs = 120_000,\n            pollMs = 1_000,\n            onProgress\n        } = opts;\n\n        const provider = this.provider;\n        const started = Date.now();\n\n        while (true) {\n            // Try to fetch the mined receipt\n            const receipt = await provider.getTransactionReceipt(tx.hash);\n            console.log('=================',receipt);\n\n            if (receipt) {\n                // If mined but reverted (status === 0) → obtain and decode revert data\n                if (receipt.status === 0) {\n                    try{\n                        await provider.call({\n                            ...tx,\n                            blockTag: receipt.blockNumber\n                        });\n                    }catch(error: any){\n                        error.receipt = receipt;\n                        await this.revertError(error, functionName, args, overrides);\n                    }\n                }\n\n                // Count confirmations\n                const currentBlock = await provider.getBlockNumber();\n                const confNow = currentBlock - receipt.blockNumber + 1;\n\n                if (onProgress) onProgress(confNow);\n\n                // Enough confirmations?  ➜  resolve with the receipt\n                if (confNow >= confirmations) return receipt;\n            }\n\n            // Abort if we have exceeded the timeout\n            if (Date.now() - started > timeoutMs) {\n                throw new Error(`Transaction still pending after ${timeoutMs} ms`);\n            }\n\n            // Detect dropped / replaced transactions\n            const mempoolTx = await provider.getTransaction(tx.hash);\n            if (!mempoolTx && !receipt) {\n                throw new Error(\"Transaction was dropped or replaced without a receipt\");\n            }\n\n            // Sleep before the next poll\n            if(pollMs < 60_000){\n                pollMs += pollMs*20/100;\n            }\n            await new Promise((r) => setTimeout(r, pollMs));\n        }\n    }\n\n    async verifyContractExists(): Promise<boolean | void> {\n        if(this.verifiedContract) return true;\n        const code = await this.provider.getCode(this.address);\n        if (code === '0x') {\n            const message = `❌ Contract not found at ${this.address} on the ${this.network.name} network`;\n            throw new Error(message);\n        }\n        this.verifiedContract = true;\n        return true;\n    }\n\n    /**\n     * Decode a revert error thrown by a failed contract transaction.\n     *\n     * @param err - The caught error object (usually from try/catch around tx).\n     * @returns A formatted string with the error name and arguments, or undefined if cannot decode.\n     */\n    decodeRevertError(err: unknown): ErrorDescription | undefined {\n        if ( typeof err !== \"object\" || err === null || !(\"data\" in err) ) {\n            return;\n        }\n\n        const data = (err as { data?: string }).data;\n        if (!data || typeof data !== \"string\") return;\n\n        try {\n            const interfaces = [\n                new Interface(this.abi),\n                new Interface(IERC20Errors),\n            ];\n            for (const iface of interfaces) {\n                try {\n                    const parsed: null | ErrorDescription = iface.parseError(data);\n                    if (parsed) {\n                        return parsed;\n                    }\n                } catch (_) {\n                    continue;\n                }\n            }\n        } catch (decodeErr) {\n            return;\n        }\n    }\n\n    /**\n     * Handle and re-throw a contract revert error with decoded context.\n     *\n     * This function attempts to decode the revert reason from a caught error\n     * using `this.decodeRevertError()`. If decoding is successful, it logs\n     * and throws a formatted error with the decoded reason. If decoding fails,\n     * it logs the raw error and throws a generic fallback message.\n     *\n     * @param err - The error object caught from a failed contract transaction.\n     * @throws An Error containing the decoded or fallback message.\n     */\n    async revertError(err: any, functionName: string, args?: any[], overrides?:{}) {\n        // if(err.code == 'CALL_EXCEPTION'){\n            const fn = this.iface.getFunction(functionName);\n            if(fn){\n                let invocation = new ErrorDescription(fn, fn?.selector, args as Result);\n                // err.invocation = utils.errorDescriptionToString(invocation);\n                err.invocation = {\n                    name: invocation.name,\n                    signature: invocation.signature,\n                    args: invocation.args,\n                    selector: invocation.selector,\n                    message: utils.errorDescriptionToString(invocation),\n                    overrides\n                };\n            }\n            const decodedError = this.decodeRevertError(err);\n            if(decodedError){\n                err.reason = utils.errorDescriptionToString(decodedError);\n                // err.revert = utils.errorDescriptionToString(decodedError);\n                err.revert = {\n                    name: decodedError.name,\n                    signature: decodedError.signature,\n                    args: decodedError.args,\n                    selector: decodedError.selector,\n                    message: utils.errorDescriptionToString(decodedError)\n                };\n            }\n            if(err.invocation?.message){\n                err.message = 'GeniDex Error:\\n' + err.invocation.message;\n            }\n            if(err.revert?.message){\n                err.message += '\\n'+err.revert.message;\n            }\n            if(!err.revert || !err.revert.message){\n                err.message = utils.jsonToString(err);\n            }\n        // }\n        throw err;\n    }\n\n    /**\n     * Map an array of contract call arguments to an object using ABI parameter names.\n     *\n     * @param methodName - The name of the function in the ABI.\n     * @param args - Positional arguments array (must match ABI order).\n     * @returns Object mapping parameter names to values.\n     */\n    mapArgsToObject(methodName: string, args: any[]): Record<string, any> {\n        const iface = new Interface(this.abi);\n        const fn = iface.getFunction(methodName);\n        console.log(fn);\n        if (fn?.inputs.length !== args.length) {\n            throw new Error(`Argument count mismatch for ${methodName}`);\n        }\n        const result: Record<string, any> = {};\n        fn.inputs.forEach((input, index) => {\n            result[input.name] = args[index];\n        });\n        return result;\n    }\n\n    verifyMethodExists(contract: Contract, method: string) {\n        if (typeof contract[method] !== \"function\") {\n            throw new Error(`Method \"${method}\" does not exist on the contract.`);\n        }\n    }\n\n    async verifyStaticCallSucceeds(\n        contract: Contract,\n        method: string,\n        args: any[],\n        overrides: any = {}\n    ) {\n        try {\n            await contract.getFunction(method).staticCall(...args, overrides);\n        } catch (error: any) {\n            await this.revertError(error, method, args, overrides);\n        }\n    }\n\n    async pause(signer: Signer){\n        const overrides = {\n            // gasPrice: parseUnits('300', 'gwei')\n        }\n        return await this.writeContract({signer, method: 'pause', args:[], overrides});\n    }\n\n    async unpause(signer: Signer){\n        const overrides = {\n            // gasPrice: parseUnits('300', 'gwei')\n        }\n        return await this.writeContract({signer, method: 'unpause', args:[], overrides});\n    }\n\n}"]}