{"version":3,"file":"buy.orders.js","sourceRoot":"","sources":["../../../../src/contracts/buy.orders.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport { BigNumberish, Contract, ContractTransactionResponse, getBigInt, Signer, TransactionReceipt, TransactionResponse, ZeroAddress } from 'ethers';\nimport { GeniDex } from './genidex';\nimport { OutputOrder, cancelOrderParams, orderParams } from '../types';\n\n\n\n/**\n * @group Contracts\n */\nexport class BuyOrders {\n    genidex!: GeniDex;\n    contract: Contract;\n\n    constructor(_genidex: GeniDex) {\n        this.genidex = _genidex;\n        this.contract = this.genidex.contract;\n    }\n\n    /**\n     * Place a buy order on the specified market.\n     *\n     * This function:\n     * 1. Fetches matching sell order IDs for the given market and price.\n     * 2. Randomly selects a filled buy order ID (if applicable).\n     * 3. Submits a `placeBuyOrder` transaction with all parameters.\n     *\n     * @param params - Object containing all order parameters.\n     * @param params.signer - Signer used to send the transaction.\n     * @param params.marketId - ID of the market (e.g. 1).\n     * @param params.normPrice - Price per unit (normalized to 18 decimals).\n     * @param params.normQuantity - Quantity to buy (base token, 18 decimals).\n     * @param params.referrer - Referral address (or zero address).\n     * @returns TransactionResponse.\n     */\n    async placeBuyOrder({\n        signer, marketId,\n        normPrice, normQuantity,\n        referrer = ZeroAddress,\n        overrides = {}\n    }: orderParams ): Promise<ContractTransactionResponse | undefined> {\n        const sellOrderIds = await this.genidex.sellOrders.getMatchingSellOrderIds(\n            marketId,\n            normPrice,\n            normQuantity\n        );\n        const filledBuyOrderId = await this.randomFilledBuyOrderID(marketId);\n        const args = [\n            marketId,\n            normPrice,\n            normQuantity,\n            filledBuyOrderId,\n            sellOrderIds,\n            referrer,\n        ];\n\n        const method = 'placeBuyOrder';\n        return await this.genidex.writeContract({signer, method, args, overrides});\n    }\n\n    /**\n     * Cancel a buy order on the specified market.\n     *\n     * @param signer - The signer (wallet) performing the cancellation.\n     * @param marketId - The ID of the market where the buy order exists.\n     * @param orderIndex - The index of the buy order to cancel.\n     * @returns The transaction response object.\n     */\n    async cancelBuyOrder({\n        signer,\n        marketId,\n        orderIndex,\n        overrides = {}\n    }: cancelOrderParams): Promise<TransactionResponse | undefined> {\n        const args = [marketId, orderIndex];\n        const method = 'cancelBuyOrder';\n        return await this.genidex.writeContract({signer, method, args, overrides});\n    }\n\n    /**\n     * Fetch list of buy orders for a market with price <= maxPrice.\n     *\n     * @param marketId - ID of the market\n     * @param maxPrice - Max acceptable price (normalized to 18 decimals)\n     * @returns Array of matching OutputOrder objects\n     */\n    async getBuyOrders(marketId: BigNumberish, maxPrice: BigNumberish): Promise<OutputOrder[]> {\n        const rawOrders = await this.contract[\"getBuyOrders(uint256,uint256)\"](marketId, maxPrice);\n        return rawOrders.map((o: any) => ({\n            id: BigInt(o.id.toString()),\n            trader: o.trader,\n            price: BigInt(o.price.toString()),\n            quantity: BigInt(o.quantity.toString()),\n        }));\n    }\n\n    async getAllBuyOrders(marketId: BigNumberish){\n        const rawOrders = [];\n        const ordersTotal = await this.getBuyOrdersLength(marketId);\n        const pageSize = 3700;\n        let offset = 0;\n\n        const typeOrder = 0;// buy: 0, sell: 1\n        while (offset < ordersTotal) {\n            const page = await this.contract[\"getOrders\"](typeOrder, marketId, offset, pageSize);\n            offset += pageSize;\n            rawOrders.push(...page);\n        }\n        // return allOrders;\n        return rawOrders.map((o: any, index: number) => ({\n            id: BigInt(index.toString()),\n            trader: o.trader,\n            price: BigInt(o.price.toString()),\n            quantity: BigInt(o.quantity.toString()),\n        }));\n    }\n\n    async getBuyOrdersLength(marketId: BigNumberish): Promise<bigint> {\n        const buyOrderLength = await this.contract[\"getBuyOrdersLength\"](marketId);\n        return buyOrderLength;\n    }\n\n    /**\n     * Sorts an array of sell orders by price descending (high to low).\n     * @param orders - Array of sell orders\n     * @returns Sorted array\n     */\n    sortBuyOrders(orders: OutputOrder[]): OutputOrder[] {\n        return [...orders].sort((a, b) => {\n            if (a.price < b.price) return 1;\n            if (a.price > b.price) return -1;\n            return 0;\n        });\n    }\n\n    /**\n     * Selects buy order IDs (sorted ascending by price) such that\n     * the cumulative quantity exceeds or equals the requested normQuantity.\n     *\n     * @param sortedBuyOrders - Array of sell orders sorted by price ascending\n     * @param normQuantity - Maximum total quantity needed\n     * @returns Array of order IDs\n     */\n    getBuyOrderIds(sortedBuyOrders: OutputOrder[], normQuantity: BigNumberish): BigNumberish[] {\n        const selectedIds: BigNumberish[] = [];\n        let total = 0n;\n        const target = getBigInt(normQuantity);\n        for (const order of sortedBuyOrders) {\n            if (total >= target) break;\n            selectedIds.push(order.id);\n            total += order.quantity;\n        }\n        return selectedIds;\n    }\n\n    async getFilledBuyOrderIds(marketId: BigNumberish, limit: BigNumberish=1000) {\n        const typeOrder = 0;// buy: 0, sell: 1\n        const rawIds: bigint[] = await this.contract[\"getFilledOrders\"](typeOrder, marketId, limit);\n        // console.log(rawOrders);\n        return rawIds.map(id => BigInt(id.toString()));\n    }\n\n    /**\n     * Returns a random ID of a buy order that has been fully filled (quantity == 0).\n     *\n     * @param marketId - ID of the market\n     * @returns Random filled order ID (bigint) or null if none found\n     */\n    async randomFilledBuyOrderID(marketId: BigNumberish): Promise<bigint | null> {\n        // const filledBuyOrderIDs = this.genidex.getFilledOrderIDs(marketBuyOrders);\n        const filledBuyOrderIDs = await this.getFilledBuyOrderIds(marketId);\n        const random = Math.floor(Math.random() * filledBuyOrderIDs.length);\n        const filledBuyOrderId = filledBuyOrderIDs[random];\n        return filledBuyOrderId || 0n;\n    }\n\n    /**\n     * Get a list of buy order IDs that can match a sell order based on price and quantity.\n     *\n     * @param marketId - The market identifier.\n     * @param normPrice - The normalized minimum acceptable price (18 decimals).\n     * @param normQuantity - The normalized quantity to sell (18 decimals).\n     * @returns An array of matching buy order IDs, sorted by best price first.\n     */\n    async getMatchingBuyOrderIds(\n        marketId: BigNumberish,\n        normPrice: BigNumberish,\n        normQuantity: BigNumberish\n    ) {\n        const sellOrders: OutputOrder[] = await this.getBuyOrders(marketId, normPrice);\n        const sortedBuyOrders: OutputOrder[] = this.sortBuyOrders(sellOrders);\n        const buyOrderIds = this.genidex.getMatchingOrderIds(sortedBuyOrders, normQuantity);\n        return buyOrderIds;\n    }\n\n}\n"]}